from Crypto.Util.number import inverse, long_to_bytes
from gmpy2 import isqrt
import math

e = 65537

n = 84579385253850209980531118129485716360575269582423585759001305965013034395499445816183248675447710453177558996114910965695049824431833160231360553529286419317374940825879760576417322050461035628520331998356731488662783964882867470865445762024182798458285340930223702904421982112483822508094601373760076526513

result = 17668912838657324025145974741772418705042500725249546941532860274474967308105880488339989276944955996505219230783445824255159192918050910923274393622976856688164873271519593664637389313627158186713709798641755794557335453137110328826176249263923330675599181311888750799280794535134718146446678320514719996743

'''
primes p and q are close to each other...
so I can factorize using Fermat's factorization 
p = a + b
q = a - b
n = p * q = (a+b)(a-b) = a^2 - b^2 
'''

a = b = math.isqrt(n) # start from the midpoint
while True:
    if a * a < n: # a is too small then skip to next round
        a += 1
        continue
    b = math.isqrt(pow(a, 2) - n) # calculate b at each step from n = a^2 - b^2 -> b = sqrt(a^2 - n)
    if a**2 - b**2 == n: # a and b found
        break
    a += 1

# now I have p and q
p = a + b
q = a - b
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(result, d, n) # decrypt the message
print(long_to_bytes(m))


