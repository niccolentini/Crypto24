from Crypto.Util.number import long_to_bytes, inverse
from pwn import *
import math

r = remote('130.192.5.212', 6646)

c = int(r.recvline().strip().decode())
e = 65537

# here I got 3 tries to find the value of n. To do that I will send two requests with different bases 
# and then I will calculate n using the formula n = gcd(res1 - c1_actual, res2 - c2_actual)

b1 = 2
b2 = 3

r.sendline(f'e{b1}'.encode())
res1 = int(r.recvline().strip().decode())
print(f'res1: {res1}')

r.sendline(f'e{b2}'.encode())
res2 = int(r.recvline().strip().decode())
print(f'res2: {res2}')

c1_actual = pow(b1, e)
c2_actual = pow(b2, e) 

'''
res1 - c1_actual = n * x
res2 - c2_actual = n * y
n = gcd(res1 - c1_actual, res2 - c2_actual)

This works because are both multiples of n and the modulus has not been applied yet
'''

n = math.gcd(res1 - c1_actual, res2 - c2_actual) 
print(f'n: {n}')

# now is the same attack as in 5/exploit.py bcause I have n and one request left
while True:
    x = random.randint(2, n-1)
    if math.gcd(x,n) == 1:
        break

print(x)
r_e = pow(x, e, n)  

c_prime = (c * r_e) % n

r.sendline(f'd{c_prime}'.encode())

d_c_prime = int(r.recvline().strip().decode())

m_prime = d_c_prime

m = (m_prime * inverse(x, n)) % n

print(long_to_bytes(m))