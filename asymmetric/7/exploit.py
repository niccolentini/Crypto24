from pwn import *
from Crypto.Util.number import long_to_bytes
from math import log2

r = remote('130.192.5.212', 6647)
n = int(r.recvline().strip().decode())
c = int(r.recvline().strip().decode())
e = 65537

'''
Since I have the opportunity to send multiple requests to the server, I can use the LSB Oracle attack to decrypt the flag.
The attack is as follows:
c=m^e mod n and m < n
we send c' = (2^e)c = 2^e m^e=(2m)^e
 if 2m < n the LSB is 0 [2m is a left shift e there is no overflow]
 therefore m < n/2
 m is in [0,n/2]
 if 2m > n the LSB is 1 [2m is a left shift, overflow]
 there is an overflow
 2m (mod n) = 2m - n (mod n)
 n is odd -> 2m - n is odd
 m > n/2 -> m is in [n/2,n]
send 4ec, 8ec, â€¦, 2e*nbitc and do the same interval shrinking
 n bit is the size (in bit) of the modulus
 log (n) requests to the oracle
'''

interval = [0, n]

iterations = math.ceil(log2(n)) # iterations required to find the flag

for i in range(1, iterations + 1):

    ci = (pow(2, i * e, n) * c)
    payload = f'{ci}'
    r.sendline(payload.encode())

    res = int(r.recvline().strip().decode())

    if res == 0:
        interval[1] = (interval[1] + interval[0]) // 2 # move to the left interval
    else:
        interval[0] = (interval[1] + interval[0]) // 2 # move to the right interval

    print(interval)

m = interval[0]

print(long_to_bytes(m))
    