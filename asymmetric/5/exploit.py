from pwn import *
from Crypto.Util.number import long_to_bytes, inverse

e = 65537

def extended_gcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        gcd, x, y = extended_gcd(b % a, a)
        return (gcd, y - (b // a) * x, x)

r = remote('130.192.5.212', 6645)
n = int(r.recvline().strip().decode())
c = int(r.recvline().strip().decode())

while True:
    x = random.randint(2, n-1)
    if extended_gcd(x, n)[0] == 1: # find a coprime number with n because x must be invertible mod n 
        break

print(x)
r_e = pow(x, e, n)  # ciphertext of x
c_prime = (c * r_e) % n # c' = c * r_e mod n = m^e * x^e mod n = (m * x)^e mod n
r.sendline(f'd{c_prime}'.encode()) # get m * x mod n
d_c_prime = int(r.recvline().strip().decode()) 
m_prime = d_c_prime 
m = (m_prime * inverse(x, n)) % n # m = m' * x^-1 mod n
print(long_to_bytes(m))