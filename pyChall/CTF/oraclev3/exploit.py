from pwn import *
from math import ceil
import string
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES

# connect to the server

r = remote('130.192.5.212', 6543)

def encrypt(data):
    r.sendlineafter(b'> ', b'enc')
    r.sendlineafter(b'> ', data.encode())
    return bytes.fromhex(r.recvline().strip().decode())


# First understand the padding length

block_size = AES.block_size

'''
QUESTO E' FOOL THE ORACLE V2 MA CON PADDING VARIABILE. IN PRATICA PER TROVARE IL PADDING INIZIALE DEVO METTERE UN BLOCCO DI A E DUE BLOCCHI 
DI X E VEDERE SE I DUE BLOCCHI DI X SONO UGUALI IPOTIZZANO UN NUMERO PER IL PADDING E METTENDO UN NUMERO DI A TALE A BLOCCO - PADDING_IPOTIZZATO.
SE AZZECCO IL NUMERO DEL PADDING AVRO': [PADDING+AAAA]+[XXXX]+[XXXX] E I DUE BLOCCHI DI X SARANNO UGUALI.
'''

for i in range(1, 16):                                     # here we are trying to find the padding length 
    data = b'A' * (block_size - i) + b'X' * 2 * block_size # if the padding is the right one, the last two blocks of X will be the same
    cipher = encrypt(data.hex())                           # If the padding is wrong the last two blocks will be different
    if cipher[16:32] == cipher[32:48]:
        padding_len = i
        print(f"Padding len: {padding_len}")
        break

guessed = b''

flag = "CRYPTO24{" + "?" * 36 + "}"
print(f"Flag: {flag}")


after_padding = b"A" * (block_size - padding_len)

flag_len = len('CRYPTO24{}') + 36

data_len = math.ceil((flag_len + padding_len) / block_size) * block_size

print(f"Data len: {data_len}")


for i in range(flag_len):

    if i < 16:
        data1 = after_padding + (b'A' * (block_size - 1 - i))
    else:
        data1 = after_padding + guessed[-(block_size - 1):]

    data2 = b'A' * (data_len -1 -i)

    found = False

    for char in string.printable:

        if (i < block_size):
            data = data1 + guessed + char.encode() + data2
        else:
            data = data1 + char.encode() + data2

        cipher = encrypt(data.hex())

        if cipher[16:32] == cipher[80:96]:
            guessed += char.encode()
            print(f"Guessed: {guessed}")
            found = True
            break
    
    if not found:
        print("Failed to find character")
        exit(1)
        
print(guessed)