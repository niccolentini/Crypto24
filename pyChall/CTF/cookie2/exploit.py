from pwn import *
from Crypto.Util.number import long_to_bytes, bytes_to_long

'''
IN QUESTO ATTACCO SI UTILIZZA UNA VULNERABILITA' DI AES IN ECB MODE ANDANDO A CIFRARE UN MESSAGGIO IN MANIERA A NOI FAVOREVOLE PER POTER SCAMBIARE I BLOCCHI DEL COOKIE
'''

# Connect to the server

r = remote('130.192.5.212', 6552)

r.recvuntil(b'Username: ')


'''
block size of AES is 16 bytes

the cookie created by the server is in the form of "username=...&admin=false"
which is 21 bytes long

the cookie is then padded using PKCS7 padding

the cookie is then encrypted using AES in ECB mode

i cannot use symbols like "&" and "=" in the username field


payload = username=AAAAAAA  true\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c
          XXXXXXXXX&admin= falsePPPPPPPPPPP

          it splits values on &
'''

first_block_and_true = b'AAAAAAAtrue' # 11 bytes
second_block_padding = b'\x0c'*12 # I give a padding of 12 bytes because it is PKCS7 padding (c = 12)
third_block = b'XXXXXXXXX' # 9 bytes

# Mando "AAAAAAAtrue\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0cXXXXXXXXX" che sono 32 bytes precisi precisi che non prendono il padding
# username=AAAAAAA true\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c XXXXXXXXX&admin= falsePPPPPPPPPPP
# username=AAAAAAA XXXXXXXXX&admin= true\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c 

payload = first_block_and_true + second_block_padding + third_block

r.sendline(payload)

# Parse the cookie

cookie = long_to_bytes(int(r.recvline().strip().decode()))
print(len(cookie))


# Cookie is forged with the first block followed by the third block and then the second block 

# il nuovo cookie viene creato scambiando i vari blocchi del cookie originale pheega

new_cookie = cookie[:16] + cookie[32:48] + cookie[16:32]

r.recvuntil(b'> ')

r.sendline(b'flag')
r.recvuntil(b'Cookie: ')

r.sendline(str(bytes_to_long(new_cookie)).encode())

r.interactive()


