from pwn import *
from math import ceil
import string
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES

# connect to the server

r = remote('130.192.5.212', 6542)

def encrypt(data):
    r.sendlineafter(b'> ', b'enc')
    r.sendlineafter(b'> ', data.encode())
    return bytes.fromhex(r.recvline().strip().decode())


guessed = b''

flag = "CRYPTO24{" + "?" * 36 + "}"
print(f"Flag: {flag}")

block_size = AES.block_size

padding_len = 5 # goes before my data -> the first block is filled with padding

after_padding = b"A" * (block_size - padding_len)

flag_len = len('CRYPTO24{}') + 36

data_len = math.ceil((flag_len + padding_len) / block_size) * block_size # the length of the data 

print(f"Data len: {data_len}")


for i in range(flag_len):

    if i < 16:
        data1 = after_padding + (b'A' * (block_size - 1 - i)) # shifting the guessed part to the left, TO FILL THE FIRST BLOCK
    else:
        data1 = after_padding + guessed[-(block_size - 1):] # putting inside the block the last 15 character guessed

    data2 = b'A' * (data_len -1 -i) # padding the rest of the block to let the flag in the next block (80:96)

    found = False

    for char in string.printable: # trying all the printable characters

        if (i < block_size):
            data = data1 + guessed + char.encode() + data2 # [0:16] + guessedLessOneBlock + charToFind + [32:96]
        else:
            data = data1 + char.encode() + data2 # [0:16] + last15Guessed + charToFind + [32:96]

        cipher = encrypt(data.hex())

        if cipher[16:32] == cipher[80:96]: # the ciphertext to find is always in the range 80:96
            guessed += char.encode()
            print(f"Guessed: {guessed}")
            found = True
            break
    
    if not found:
        print("Failed to find character")
        exit(1)
print(guessed)